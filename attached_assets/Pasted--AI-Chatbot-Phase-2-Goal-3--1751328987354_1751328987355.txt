แผนการพัฒนา AI Chatbot (Phase 2, Goal 3): การจัดการบทสนทนาต่อเนื่องเอกสารนี้สรุปแนวทางการพัฒนาเพื่อเพิ่มความสามารถให้ AI Chatbot สามารถ "จดจำ" บริบทของบทสนทนาที่ผ่านมาได้ ทำให้การถาม-ตอบเป็นธรรมชาติและต่อเนื่อง1. ทำไมถึงสำคัญ? (The "Why")ปัจจุบัน Chatbot ของเราจะตอบคำถามได้แค่ทีละครั้ง โดยไม่รู้ว่าก่อนหน้านี้เราคุยอะไรกันไปบ้างสถานการณ์ปัจจุบัน:คุณ: "ใบสั่งงานที่ค้างอยู่มีกี่ใบ?"AI: "มี 5 ใบครับ"คุณ: "แล้วของลูกค้ารายไหนเยอะที่สุด?"AI: "ขออภัยครับ ไม่ทราบว่า 'ของ' ที่คุณหมายถึงคืออะไร" (เพราะ AI ลืมไปแล้วว่ากำลังคุยเรื่องใบสั่งงาน)สิ่งที่เราต้องการ (เป้าหมายของ Phase นี้):คุณ: "ใบสั่งงานที่ค้างอยู่มีกี่ใบ?"AI: "มี 5 ใบครับ"คุณ: "แล้วของลูกค้ารายไหนเยอะที่สุด?"AI: "จาก 5 ใบสั่งงานที่ค้างอยู่ เป็นของ 'บริษัท A' จำนวน 3 ใบ ซึ่งเยอะที่สุดครับ" (AI จำได้และตอบคำถามต่อเนื่องได้)2. หลักการทำงาน (The "How")เราจะทำให้ Frontend ส่ง "ประวัติการสนทนาล่าสุด" ไปให้ Backend ทุกครั้งที่มีการส่งคำถามใหม่ และ Backend จะนำประวัติทั้งหมดนี้ไปประกอบเป็น Prompt ใหม่ที่สมบูรณ์ยิ่งขึ้นFlow การทำงานใหม่:[Frontend] ผู้ใช้พิมพ์คำถามใหม่[Frontend] รวบรวมประวัติการแชทล่าสุด (เช่น 4-6 ข้อความหลังสุด) + คำถามใหม่[Frontend] -> [Backend] ส่งข้อมูลทั้งหมดไปที่ API /api/ai/chat[Backend] รับประวัติการแชทและคำถามใหม่[Backend] ตรวจจับ Keyword และดึงข้อมูลจาก Database (เหมือนเดิม)[Backend] สร้าง Prompt ใหม่ ที่ประกอบด้วย:ประวัติการสนทนาที่จัดรูปแบบแล้วบริบทจากฐานข้อมูล (ถ้ามี)คำถามล่าสุดของผู้ใช้[Backend] -> [Gemini API] ส่ง finalPrompt ที่สมบูรณ์ที่สุดไปให้ AI[Backend] -> [Frontend] ส่งคำตอบกลับไปแสดงผล3. แผนการพัฒนาในทางเทคนิคฝั่ง Frontend (Client-Side)การจัดการ State: State ที่ใช้เก็บข้อความในแชท ควรจะเป็น Array ของ Object โดยแต่ละ Object มี role ('user' หรือ 'model') และ content (ข้อความ)const [messages, setMessages] = useState([
  { role: 'model', content: 'สวัสดีครับ/ค่ะ' },
  { role: 'user', content: 'ใบสั่งงานที่ค้างอยู่มีกี่ใบ?' },
  { role: 'model', content: 'มี 5 ใบครับ' }
]);
การส่ง Request: เมื่อจะส่งคำถามใหม่ ให้ส่ง messages ทั้งหมด (หรือส่วนหนึ่ง) ไปใน Body ของ Request ด้วย// ตัวอย่าง Body ที่จะส่งไป Backend
{
  "prompt": "แล้วของลูกค้ารายไหนเยอะที่สุด?",
  "history": [
    { "role": "user", "content": "ใบสั่งงานที่ค้างอยู่มีกี่ใบ?" },
    { "role": "model", "content": "มี 5 ใบครับ" }
  ]
}
ฝั่ง Backend (Server-Side)อัปเดต API (routes.ts):ปรับแก้ POST /api/ai/chat ให้รับ history (optional array) จาก req.bodyอัปเดต Prompt Formatter (prompt-formatter.ts):สร้างฟังก์ชันใหม่ formatConversationHistory(history) เพื่อแปลง Array ของข้อความให้เป็นรูปแบบที่ Gemini เข้าใจปรับปรุง Logic การสร้าง Prompt (routes.ts):เรียกใช้ formatConversationHistory แล้วนำผลลัพธ์ไปใส่ไว้ส่วนบนสุดของ finalPrompt4. ข้อเสนอแนะสำหรับขั้นตอนแรกผมแนะนำให้เราเริ่มจากการ อัปเดต Backend ก่อน เพื่อให้พร้อมรับประวัติการสนทนาสิ่งที่เราจะทำ:สร้างฟังก์ชัน formatConversationHistory ในไฟล์ prompt-formatter.tsปรับปรุง API /api/ai/chat ใน routes.ts ให้รองรับและประมวลผล history ที่ส่งมาจาก Frontendถ้าคุณเห็นด้วยกับแผนนี้ เรามาเริ่มลงมือเขียนโค้ดสำหรับ Backend กันได้เลยครับ!